name: Gateway > Release

permissions:
  contents: read

on:
  push:
    branches:
      - main
      - development

  workflow_dispatch:

concurrency:
  group: 'gateway-release'
  cancel-in-progress: true

jobs:
  build:
    name: Build Gateway
    runs-on: self-hosted
    environment: gateway
    steps:
      - name: Cleanup Docker Resources Before Build
        continue-on-error: true
        run: |
          echo "Cleaning up Docker resources before build..."
          # Remove dangling images
          docker image prune -f || true
          # Remove all build cache
          docker builder prune -f -a || true
          # Remove all unused images (not just dangling)
          docker image prune -a -f || true
          # Remove stopped containers
          docker container prune -f || true

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Update environment variables
        run: |
          # Create gateway .env.gateway file
          if [ -f ".env.gateway" ]; then
            echo "Gateway .env.gateway file exists. Removing it."
            rm .env.gateway
          fi

          echo 'WEBSRV_PORT=9999' >> .env.gateway
          echo 'WS_PORT=9000' >> .env.gateway
          echo 'WEBSRV_USESSL=false' >> .env.gateway
          echo 'GATEWAY_AUTH_KEY="${{ secrets.GATEWAY_AUTH_KEY }}"' >> .env.gateway
          echo 'HEARTBEAT_INTERVAL=5000' >> .env.gateway
          echo 'SERVER_TIMEOUT=15000' >> .env.gateway
          echo 'SESSION_TIMEOUT=1800000' >> .env.gateway

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Generate Gateway Config
        env:
          WEBSRV_PORT: 9999
          WS_PORT: 9000
          GATEWAY_AUTH_KEY: ${{ secrets.GATEWAY_AUTH_KEY }}
          HEARTBEAT_INTERVAL: 5000
          SERVER_TIMEOUT: 15000
          SESSION_TIMEOUT: 1800000
        run: |
          bun run create-config

      - name: Build Docker Image
        env:
          GATEWAY_AUTH_KEY: ${{ secrets.GATEWAY_AUTH_KEY }}
          HTTP_PORT: 9999
          HTTPS_PORT: 443
          WS_PORT: 9000
        run: |
          docker compose build

  backup-docker-images:
    name: Backup Current Docker Images
    runs-on: self-hosted
    environment: gateway
    needs: [build]
    steps:
      - name: Tag current images as backup
        continue-on-error: true
        run: |
          # Get list of running containers and their images
          RUNNING_IMAGES=$(docker compose ps --format json 2>/dev/null | jq -r '.Image' 2>/dev/null || echo "")

          if [ -z "$RUNNING_IMAGES" ]; then
            echo "No running containers found, checking for existing images..."
            # Try to get images from docker-compose config
            IMAGES=$(docker compose config 2>/dev/null | grep 'image:' | awk '{print $2}' || echo "")

            if [ -z "$IMAGES" ]; then
              echo "No images found to backup, skipping..."
              exit 0
            fi
            RUNNING_IMAGES="$IMAGES"
          fi

          echo "Backing up current Docker images..."
          # Remove duplicates and filter out SHA256 hashes
          UNIQUE_IMAGES=$(echo "$RUNNING_IMAGES" | sort -u | grep -v "^sha256:" | grep -v "^$")

          if [ -z "$UNIQUE_IMAGES" ]; then
            echo "No valid images to backup"
            exit 0
          fi

          while IFS= read -r image; do
            if [ -n "$image" ] && [ "$image" != "sha256:"* ]; then
              # Check if image exists before tagging
              if docker image inspect "$image" >/dev/null 2>&1; then
                echo "Tagging $image as ${image}-backup"
                docker tag "$image" "${image}-backup" || echo "Failed to tag $image"
              else
                echo "Image $image does not exist, skipping..."
              fi
            fi
          done <<< "$UNIQUE_IMAGES"

  stop-docker-container:
    name: Stop Docker Container
    runs-on: self-hosted
    environment: gateway
    needs: [backup-docker-images]
    steps:
      - name: Stop Docker Container
        run: |
          docker compose down || echo "No container to stop"

  start-docker-container:
    name: Start Docker Container
    runs-on: self-hosted
    environment: gateway
    needs: [stop-docker-container]
    steps:
      - name: Start Docker Services
        env:
          GATEWAY_AUTH_KEY: ${{ secrets.GATEWAY_AUTH_KEY }}
          HTTP_PORT: 9999
          HTTPS_PORT: 443
          WS_PORT: 9000
        run: |
          docker compose up -d

  verify-docker-container:
    name: Verify Docker Container is Running
    runs-on: self-hosted
    environment: gateway
    needs: [start-docker-container]
    outputs:
      status: ${{ steps.verify.outcome }}
    steps:
      - name: Wait for services and check logs
        id: verify
        continue-on-error: true
        run: |
          echo "Waiting 10 seconds for services to start..."
          sleep 10

          echo "=== Docker Container Status ==="
          docker compose ps

          echo ""
          echo "=== Gateway Logs ==="
          docker compose logs gateway --tail=100

          echo ""
          echo "=== Checking for success indicators ==="
          LOGS=$(docker compose logs)

          if echo "$LOGS" | grep -qi "Gateway Load Balancer\\|HTTP Server running\\|WebSocket Server running"; then
            echo "✅ Gateway started successfully"
            exit 0
          else
            echo "❌ Gateway did NOT start properly"
            echo "Check logs above for errors"
            exit 1
          fi

      - name: Check verification result
        if: steps.verify.outcome == 'failure'
        run: |
          echo "Verification failed, triggering rollback..."
          exit 1

  rollback:
    name: Rollback to Previous Docker Images
    runs-on: self-hosted
    environment: gateway
    needs: [verify-docker-container]
    if: failure() && needs.verify-docker-container.outputs.status == 'failure'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Stop failed containers
        run: |
          echo "Stopping failed Docker containers..."
          docker compose down || echo "No containers to stop"

      - name: Restore backup images
        run: |
          echo "Restoring backup Docker images..."

          # Find all backup images
          BACKUP_IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -- "-backup$" || echo "")

          if [ -n "$BACKUP_IMAGES" ]; then
            while IFS= read -r backup_image; do
              if [ -n "$backup_image" ]; then
                # Remove -backup suffix to get original image name
                original_image="${backup_image%-backup}"
                echo "Restoring $backup_image to $original_image"

                # Force remove the new (failed) image if it exists
                docker rmi -f "$original_image" 2>/dev/null || echo "No new image to remove"

                # Re-tag backup image to original name
                docker tag "$backup_image" "$original_image"
              fi
            done <<< "$BACKUP_IMAGES"
          else
            echo "No backup images found to restore"
            exit 1
          fi

          # Clean up failed build artifacts
          echo "Cleaning up failed build artifacts..."
          docker image prune -f || true
          docker builder prune -f || true

      - name: Start containers with backup images
        env:
          GATEWAY_AUTH_KEY: ${{ secrets.GATEWAY_AUTH_KEY }}
          HTTP_PORT: 9999
          HTTPS_PORT: 443
          WS_PORT: 9000
        run: |
          echo "Starting Docker containers with backup images..."
          docker compose up -d

      - name: Verify rollback
        run: |
          echo "Waiting 10 seconds for services to start..."
          sleep 10

          echo "=== Docker Container Status ==="
          docker compose ps

          echo ""
          echo "=== Fetching Docker logs ==="
          LOGS=$(docker compose logs --tail=100)

          echo "$LOGS"

          if echo "$LOGS" | grep -qi "Gateway Load Balancer\\|HTTP Server running\\|WebSocket Server running"; then
            echo "✅ Rollback successful - Previous version is running"
          else
            echo "❌ Rollback failed - Manual intervention required"
            exit 1
          fi

  cleanup-failed:
    name: Cleanup Failed Build Artifacts
    runs-on: self-hosted
    environment: gateway
    needs: [verify-docker-container]
    if: failure()
    steps:
      - name: Remove Failed Build Artifacts
        continue-on-error: true
        run: |
          echo "Cleaning up failed build artifacts..."
          docker image prune -a -f || true
          docker builder prune -f -a || true
          docker container prune -f || true

  cleanup:
    name: Cleanup Old Docker Images
    runs-on: self-hosted
    environment: gateway
    needs: [start-docker-container, verify-docker-container]
    if: success() && needs.verify-docker-container.outputs.status == 'success'
    steps:
      - name: Remove Backup and Unused Docker Images
        run: |
          echo "Removing backup Docker images..."
          # Remove all backup images
          BACKUP_IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -- "-backup$" || echo "")

          if [ -n "$BACKUP_IMAGES" ]; then
            while IFS= read -r backup_image; do
              if [ -n "$backup_image" ]; then
                echo "Removing backup image: $backup_image"
                docker rmi "$backup_image" || echo "Failed to remove $backup_image"
              fi
            done <<< "$BACKUP_IMAGES"
          else
            echo "No backup images found"
          fi

          echo "Removing all unused Docker images and build cache..."
          docker image prune -a -f || true
          docker builder prune -f -a || true
          docker container prune -f || true
          docker volume prune -f || true
